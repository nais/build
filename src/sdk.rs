use thiserror::Error;

#[derive(Error, Debug)]
pub enum DetectBuildTargetError {
    #[error("filesystem error: {0}")]
    FilesystemError(#[from] std::io::Error),

    #[error("can't find {1}: {0} ")]
    FileError(std::io::Error, String),

    #[error("target name is empty")]
    EmptyFilename,
}

#[derive(Error, Debug)]
pub enum Error {
    #[error("detect build target: {0}")]
    DetectBuildTargetError(#[from] DetectBuildTargetError),
}

/// SDK is anything that can produce artifacts
pub trait DockerFileBuilder {
    fn builder_docker_image(&self) -> String;
    fn runtime_docker_image(&self) -> String;
    fn detect_build_targets(&self) -> Result<Vec<String>, DetectBuildTargetError>;
    fn dockerfile(&self) -> Result<String, Error>;
    fn filesystem_path(&self) -> String;
}

/// Build Go projects.
pub mod golang {
    use super::DetectBuildTargetError;
    use super::DockerFileBuilder;
    use super::Error;
    use log::debug;

    pub struct Golang(Config);

    pub struct Config {
        pub filesystem_path: String,
        pub docker_builder_image: String,
        pub docker_runtime_image: String,

        #[allow(dead_code)]
        pub start_hook: Option<String>,
        #[allow(dead_code)]
        pub end_hook: Option<String>,
    }

    pub fn new(cfg: Config) -> Result<Option<Golang>, Error> {
        let Ok(file_stat) = std::fs::metadata(cfg.filesystem_path.to_owned() + "/go.mod") else {
            return Ok(None);
        };
        debug!("Detected `go.mod` in project root");
        if !file_stat.is_file() {
            return Ok(None);
        }

        Ok(Some(Golang(cfg)))
    }

    impl DockerFileBuilder for Golang {
        fn builder_docker_image(&self) -> String {
            self.0.docker_builder_image.clone()
        }

        fn runtime_docker_image(&self) -> String {
            self.0.docker_runtime_image.clone()
        }

        /// Return a list of binaries that can be built.
        fn detect_build_targets(&self) -> Result<Vec<String>, DetectBuildTargetError> {
            let targets_path = format!("{}/cmd", self.0.filesystem_path.to_owned());
            std::fs::read_dir(&targets_path)
                .map_err(|e| DetectBuildTargetError::FileError(e, targets_path.clone()))?
                .map(|dir_entry| {
                    Ok(dir_entry?
                        .file_name()
                        .to_str()
                        .ok_or(DetectBuildTargetError::EmptyFilename)?
                        .to_string())
                })
                .collect()
        }

        fn dockerfile(&self) -> Result<String, Error> {
            let targets = self.detect_build_targets()?;
            let builder_image = &self.builder_docker_image();
            let runtime_image = &self.runtime_docker_image();
            let binary_build_commands: String = targets
                .iter()
                .map(|item| {
                    format!(
                        "RUN go build -a -installsuffix cgo -o /build/{} ./cmd/{}",
                        item, item
                    )
                })
                .fold(String::new(), |acc, item| acc + "\n" + &item)
                .trim()
                .to_string();
            let binary_copy_commands: String = targets
                .iter()
                .map(|item| format!("COPY --from=builder /build/{} /app/{}", item, item))
                .fold(String::new(), |acc, item| acc + "\n" + &item)
                .trim()
                .to_string();
            let default_target = if targets.len() == 1 {
                format!(r#"CMD ["/app/{}"]"#, targets[0])
            } else {
                "# Default CMD omitted due to multiple targets specified".to_string()
            };

            // TODO: some notes on Go building
            //
            // * override go.mod with any sdk-controlled version bumps, such as
            //   * "go 1.22"
            //   * "toolchain 1.22.5"
            // * go get
            // * go test
            // * linting - figure out best practice
            // * staticcheck - figure out best practice
            // * detect which binaries to build (cmd/*/*.go)
            // * go build (flags for docker, architecture, etc.)
            //
            Ok(format!(
                r#"
# Dockerfile generated by NAIS build (version) at (timestamp)

#
# Builder image
#
FROM {builder_image} AS builder
ENV GOOS=linux
ENV CGO_ENABLED=0
WORKDIR /src

# Copy go.mod and go.sum files into source directory
# so that dependencies can be downloaded before the source code.
# This is a cache optimization step (???)
COPY go.* /src/
RUN go mod download
COPY . /src

# Start hook is run before testing
#RUN ___start_hook

# Test all modules
RUN go test ./...

# Build all binaries found in ./cmd/*
{binary_build_commands}

# End hook is run after build
#RUN ___end_hook

#
# Runtime image
#
FROM {runtime_image}
WORKDIR /app
{binary_copy_commands}
{default_target}
"#,
            ))
        }

        fn filesystem_path(&self) -> String {
            self.0.filesystem_path.clone()
        }
    }
}

/// Build Java and Kotlin applications using Gradle.
pub mod gradle {
    use super::DetectBuildTargetError;
    use super::DockerFileBuilder;
    use super::Error;
    use log::debug;

    pub struct Gradle(Config);

    pub struct Config {
        pub filesystem_path: String,
        pub docker_builder_image: String,
        pub docker_runtime_image: String,
        pub settings_file: Option<String>,

        #[allow(dead_code)]
        pub start_hook: Option<String>,
        #[allow(dead_code)]
        pub end_hook: Option<String>,
    }

    pub fn new(cfg: Config) -> Result<Option<Gradle>, Error> {
        let Ok(file_stat) = std::fs::metadata(cfg.filesystem_path.to_owned() + "/gradlew") else {
            return Ok(None);
        };
        debug!("Detected `gradlew` in project root");
        if !file_stat.is_file() {
            return Ok(None);
        }

        Ok(Some(Gradle(cfg)))
    }

    impl DockerFileBuilder for Gradle {
        fn builder_docker_image(&self) -> String {
            self.0.docker_builder_image.clone()
        }

        fn runtime_docker_image(&self) -> String {
            self.0.docker_runtime_image.clone()
        }

        /// Return a list of binaries that can be built.
        fn detect_build_targets(&self) -> Result<Vec<String>, DetectBuildTargetError> {
            Ok(vec!["test".to_string(), "shadowJar".to_string()])
        }

        fn dockerfile(&self) -> Result<String, Error> {
            let targets = self.detect_build_targets()?;
            let builder_image = &self.builder_docker_image();
            let runtime_image = &self.runtime_docker_image();
            let binary_build_commands: String = targets
                .iter()
                .map(|target| {
                    match &self.0.settings_file {
                        None => format!("RUN ./gradlew {target}"),
                        Some(settings_file) => format!("RUN ./gradlew -settings-file {settings_file} {target}"),
                    }
                })
                .fold(String::new(), |acc, item| acc + "\n" + &item)
                .trim()
                .to_string();
            let binary_copy_commands: String = "COPY --from=builder /src/build/libs/app-all.jar /app/app.jar".to_string();

            let max_ram_percentage = 90;

            // TODO: evaluate and add
            // * Env (settes med fordel i nais.yml):
            // * `TZ` (kan settes automatisk i Naiserator?)
            //   * Taes opp til diskusjon
            // * `MAX_RAM_PERCENTAGE=90`
            // * `JVM_OPTS="-Xmx4G -Xms1G"` (obsolete?)
            Ok(format!(
                r#"
# Dockerfile generated by NAIS build (version) at (timestamp)

#
# Builder image
#
FROM {builder_image} AS builder

WORKDIR /src
COPY . /src

# Build all binaries found in /src/src/main/
{binary_build_commands}

# End hook is run after build
#RUN ___end_hook

#
# Runtime image
#
FROM {runtime_image}

# Default max RAM percentage is 25%, we bump it up to 90%.
# TODO: test if this is a reasonable value to use in most cases.
# TODO: should it be configurable?
# This flags denotes how much RAM the JVM heap can eat up.
# `JAVA_OPTS` is not honored by distroless; use `JDK_JAVA_OPTIONS` instead.
ENV JAVA_OPTS='-XX:MaxRAMPercentage={max_ram_percentage}'
ENV JDK_JAVA_OPTS='-XX:MaxRAMPercentage={max_ram_percentage}'

{binary_copy_commands}

CMD ["java", "-jar", "/app/app.jar"]
"#,
            ))
        }

        fn filesystem_path(&self) -> String {
            self.0.filesystem_path.clone()
        }
    }
}

/// Build Java and Kotlin applications using Maven.
pub mod maven {
    use super::DetectBuildTargetError;
    use super::DockerFileBuilder;
    use super::Error;
    use log::debug;
    use sxd_xpath::Value;

    pub struct Maven(Config);

    pub struct Config {
        pub filesystem_path: String,
        pub docker_builder_image: String,
        pub docker_runtime_image: String,

        #[allow(dead_code)]
        pub start_hook: Option<String>,
        #[allow(dead_code)]
        pub end_hook: Option<String>,
    }

    pub fn new(cfg: Config) -> Result<Option<Maven>, Error> {
        let Ok(file_stat) = std::fs::metadata(cfg.filesystem_path.to_owned() + "/pom.xml") else {
            return Ok(None);
        };

        debug!("Detected `pom.xml` in project root");

        if !file_stat.is_file() {
            return Ok(None);
        }

        Ok(Some(Maven(cfg)))
    }

    #[allow(dead_code)]
    fn pom_modules(xml_document: &str) -> Vec<String> {
        use sxd_document::parser;
        use sxd_xpath::{evaluate_xpath};

        let package = parser::parse(xml_document).expect("package");
        let doc = package.as_document();
        let value = evaluate_xpath(&doc, "/*[name()='project']/*[name()='modules']/*").expect("evaluate_xpath");

        let mut modules = if let Value::Nodeset(node_set) = value {
            node_set.iter().map(|value| value.string_value()).collect()
        } else {
            vec![]
        };
        modules.sort();
        modules
    }

    #[cfg(test)]
    #[test]
    fn pom_test_modules() {
        let xml_document = r#"<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.3.4</version>
    </parent>

    <groupId>no.nav.institusjon</groupId>
    <artifactId>institusjon</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>pom</packaging>

    <modules>
        <module>apps</module>
        <module>test-doubles</module>
        <module>libs</module>
    </modules>

    <properties>
        <asm.version>9.7.1</asm.version>
        <commons-compress.version>1.27.1</commons-compress.version>
        <confluent.version>7.7.1</confluent.version>
        <java.version>17</java.version>
        <jaxb.version>4.0.2</jaxb.version>
        <jetty.version>11.0.18</jetty.version>
        <logstash-logback-encoder.version>8.0</logstash-logback-encoder.version>
        <maven-jaxb2-plugin.version>0.15.1</maven-jaxb2-plugin.version>
        <maven-jaxb30-plugin.version>0.16.1</maven-jaxb30-plugin.version>
        <mq-jms-spring-boot-starter.version>3.3.3</mq-jms-spring-boot-starter.version>
        <ojdbc8.version>23.5.0.24.07</ojdbc8.version>
        <papertrailapp.version>1.0.0</papertrailapp.version>
        <spring-cloud-vault.version>4.1.3</spring-cloud-vault.version>
        <spring-cloud.version>2023.0.3</spring-cloud.version>
        <springdoc.version>2.6.0</springdoc.version>
        <swagger-v3.version>2.1.11</swagger-v3.version>
        <wiremock.version>3.0.0-beta-10</wiremock.version>
        <wiremock-stubs.version>1.0.0-SNAPSHOT</wiremock-stubs.version>
        <wiremock-junit-extension.version>1.0.2.RELEASE</wiremock-junit-extension.version>
    </properties>

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.ow2.asm</groupId>
                <artifactId>asm</artifactId>
                <version>${asm.version}</version>
            </dependency>
            <dependency>
                <groupId>no.nav.institusjon</groupId>
                <artifactId>wiremock-stubs</artifactId>
                <version>${wiremock-stubs.version}</version>
            </dependency>
            <dependency>
                <groupId>org.eclipse.jetty.ee10</groupId>
                <artifactId>jetty-ee10-bom</artifactId>
                <version>12.0.14</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>${spring-cloud.version}</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-compress</artifactId>
                <version>${commons-compress.version}</version>
            </dependency>
        </dependencies>
    </dependencyManagement>

    <repositories>
        <repository>
            <id>confluent</id>
            <url>https://packages.confluent.io/maven/</url>
        </repository>
    </repositories>

    <build>
        <plugins>
            <plugin>
                <artifactId>maven-enforcer-plugin</artifactId>
                <executions>
                    <execution>
                        <goals>
                            <goal>enforce</goal>
                        </goals>
                        <configuration>
                            <skip>false</skip>
                            <rules>
                                <dependencyConvergence/>
                            </rules>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

        "#;
        let strval = pom_modules(xml_document);
        assert_eq!(strval, vec!["apps", "libs", "test-doubles"]);
    }

    impl DockerFileBuilder for Maven {
        fn builder_docker_image(&self) -> String {
            self.0.docker_builder_image.clone()
        }

        fn runtime_docker_image(&self) -> String {
            self.0.docker_runtime_image.clone()
        }

        /// Return a list of binaries that can be built.
        fn detect_build_targets(&self) -> Result<Vec<String>, DetectBuildTargetError> {
            let canon = std::fs::canonicalize(self.0.filesystem_path.to_owned())?;

            Ok(vec![canon
                .file_name()
                .ok_or(DetectBuildTargetError::EmptyFilename)?
                .to_str()
                .ok_or(DetectBuildTargetError::EmptyFilename)?
                .to_string()
            ])
        }

        fn dockerfile(&self) -> Result<String, Error> {
            let targets = self.detect_build_targets()?;
            let builder_image = &self.builder_docker_image();
            let runtime_image = &self.runtime_docker_image();
            let binary_build_commands: String = targets
                .iter()
                .map(|target| {
                    format!("RUN mvn verify --no-transfer-progress --also-make-dependents --also-make --projects :{target}")
                })
                .fold(String::new(), |acc, item| acc + "\n" + &item)
                .trim()
                .to_string();
            let binary_copy_commands: String = targets
                .iter()
                .map(|target| {
                    format!("COPY --from=builder /src/build/libs/{target}.jar /app/{target}.jar")
                })
                .fold(String::new(), |acc, item| acc + "\n" + &item)
                .trim()
                .to_string();
            let default_target = if targets.len() == 1 {
                format!(r#"CMD ["java", "-jar", "/app/{}.jar"]"#, targets[0])
            } else {
                "# Default CMD omitted due to multiple targets specified".to_string()
            };

            let max_ram_percentage = 90;

            Ok(format!(
                r#"
# Dockerfile generated by NAIS build (version) at (timestamp)

#
# Builder image
#
FROM {builder_image} AS builder

WORKDIR /src
COPY . /src

# Build all binaries found in /src/src/main/
{binary_build_commands}

# End hook is run after build
#RUN ___end_hook

#
# Runtime image
#
FROM {runtime_image}

# Default max RAM percentage is 25%, we bump it up to 90%.
# TODO: test if this is a reasonable value to use in most cases.
# TODO: should it be configurable?
# This flags denotes how much RAM the JVM heap can eat up.
# `JAVA_OPTS` is not honored by distroless; use `JDK_JAVA_OPTIONS` instead.
ENV JAVA_OPTS='-XX:MaxRAMPercentage={max_ram_percentage}'
ENV JDK_JAVA_OPTS='-XX:MaxRAMPercentage={max_ram_percentage}'

{binary_copy_commands}

{default_target}
"#,
            ))
        }

        fn filesystem_path(&self) -> String {
            self.0.filesystem_path.clone()
        }
    }
}
