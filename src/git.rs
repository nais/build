use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    #[error("failed to execute Git: {0}")]
    FailedExecute(#[from] std::io::Error),

    #[error("failed to parse Git short SHA: {0}")]
    ParseGitShortSha(#[from] std::string::FromUtf8Error),

    #[error("could not parse git remote '{0}'")]
    ParseRemote(String)
}

/// Return the currently checked out Git short SHA sum.
///
/// Git-related values will be generated by the currently installed `git` executable.
/// Returns an error if `git` is not installed, or if short sha parsing failed.
///
/// If working tree is dirty, tag will be suffixed with `-dirty`.
///
/// Example output: `abcdef` or `abcdef-dirty`
pub fn short_sha(filesystem_path: &str) -> Result<String, Error> {
    let git_tree_dirty = std::process::Command::new("git")
        .arg("ls-files")
        .arg("--exclude-standard")
        .arg("--others")
        .current_dir(filesystem_path)
        .output()
        .map(|output| output.stdout.len() > 0)
        .map_err(Error::FailedExecute)?;

    let git_short_sha = std::process::Command::new("git")
        .arg("rev-parse")
        .arg("--short").arg("HEAD")
        .current_dir(filesystem_path)
        .output()
        .map(|output| String::from_utf8(output.stdout))
        .map_err(Error::FailedExecute)?
        .map_err(Error::ParseGitShortSha)
        .map(|short_sha| short_sha.trim().to_string())
        ?;

    Ok(match git_tree_dirty {
        true => format!("{git_short_sha}-dirty"),
        false => format!("{git_short_sha}"),
    })
}

pub struct RepositoryMetadata {
    pub owner: String,
    pub name: String,
}

fn parse_origin(origin: &str) -> Option<(String, String)> {
    // https://github.com/navikt/foo
    // git@github.com:navikt/foo
    // optional: suffix .git

    let owner_and_name = if origin.starts_with("git@") {
        origin.split(":").nth(1)?
    } else if origin.starts_with("https://") {
        origin.split("://").nth(1)?.splitn(2, "/").nth(1)?
    } else {
        return None
    };

    let parts: Vec<&str> = owner_and_name.splitn(2, "/")
        .collect();

    Some((parts[0].to_string(), parts[1].to_string()))
}

/// Return metadata about a Git repository.
pub fn metadata(filesystem_path: &str) -> Result<RepositoryMetadata, Error> {
    let origin_raw = std::process::Command::new("git")
        .arg("remote")
        .arg("get-url")
        .arg("origin")
        .current_dir(filesystem_path)
        .output()
        //.map(|output| output.stdout.len() > 0)
        .map_err(Error::FailedExecute)?;

    let origin_raw = String::from_utf8(origin_raw.stdout)?;
    let (owner, name) = parse_origin(&origin_raw).ok_or(Error::ParseRemote(origin_raw))?;

    Ok(RepositoryMetadata{
        owner,
        name,
    })
}
